C51 COMPILER V9.00   DA                                                                    05/05/2019 09:13:13 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DA
OBJECT MODULE PLACED IN DA.OBJ
COMPILER INVOKED BY: D:\software\keilc51\C51\BIN\C51.EXE DA.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <STC12C5A60S2.h>
   2          #include <intrins.h>
   3                  
   4          #define uchar unsigned char
   5          #define uint  unsigned int
   6          #define AddWr 0x90   //写数据地址 
   7          #define AddRd 0x91   //读数据地址
   8          /*TS12864A-3 端口定义*/
   9          #define LCD_data  P0             //数据口
  10          sbit LCD_RS  =  P3^5;            //寄存器选择输入 
  11          sbit LCD_RW  =  P3^6;            //液晶读/写控制
  12          sbit LCD_EN  =  P3^4;            //液晶使能控制
  13          sbit LCD_PSB =  P3^7;            //串/并方式控制
  14          sbit wela    =  P2^6;
  15          sbit dula    =  P2^7;
  16          sbit DJ1=P1^0;
  17          sbit DJ2=P1^1;
  18          
  19          uchar code dis1[] = {"安徽福讯"};
  20          uchar code dis2[] = {"WWW.FUXUNKJ.CN"};
  21          uchar code dis3[] = {"电压:"};
  22          uchar code mun_to_char[] = {"0123456789"}; /*定义数字跟ASCII码的关系*/
  23          
  24          bit ack;                      //应答标志位
  25          
  26          sbit SDA=P2^0;
  27          sbit SCL=P2^1;
  28                    unsigned int num1=0;
  29          void delay0(uchar x);  //x*0.14MS
  30          void beep();
  31          void  dataconv();
  32          void lcd_pos(uchar X,uchar Y);  //确定显示位置
  33          unsigned char ReadADC(unsigned char Chl);
  34          
  35          void _Nop(void)//I2C延时程序
  36          {
  37   1              int k;
  38   1              for (k=0; k<10; k++);
  39   1      
  40   1      }
  41          /*******************************************************************/
  42          /*                                                                 */
  43          /*  延时函数                                                       */
  44          /*                                                                 */
  45          /*******************************************************************/
  46          void delay(int ms)
  47          {
  48   1          while(ms--)
  49   1              {
  50   2            uchar i;
  51   2                for(i=0;i<250;i++)  
  52   2                 {
  53   3                  _nop_();                       
  54   3                      _nop_();
  55   3                      _nop_();
C51 COMPILER V9.00   DA                                                                    05/05/2019 09:13:13 PAGE 2   

  56   3                      _nop_();
  57   3                 }
  58   2              }
  59   1      }               
  60          /*******************************************************************/
  61          /*                                                                 */
  62          /*检查LCD忙状态                                                    */
  63          /*lcd_busy为1时，忙，等待。lcd-busy为0时,闲，可写指令与数据。      */
  64          /*                                                                 */
  65          /*******************************************************************/
  66          bit lcd_busy()
  67           { 
  68   1                                 
  69   1          bit result;
  70   1          P0=0X00;              //关掉数码管的信号。阻止数码管受到P0口信号的影响
  71   1          LCD_RS = 0;
  72   1          LCD_RW = 1;
  73   1          LCD_EN = 1;
  74   1          delay(1);
  75   1          result = (bit)(P0&0x80);
  76   1          LCD_EN = 0;
  77   1          return(result); 
  78   1       }
  79          /*******************************************************************/
  80          /*                                                                 */
  81          /*写指令数据到LCD                                                  */
  82          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。                             */
  83          /*                                                                 */
  84          /*******************************************************************/
  85          void lcd_wcmd(uchar cmd)
  86          {   
  87   1                               
  88   1         while(lcd_busy());
  89   1          LCD_RS = 0;
  90   1          LCD_RW = 0;
  91   1          LCD_EN = 0;
  92   1          _nop_();
  93   1          _nop_(); 
  94   1          P0 = cmd;
  95   1       delay(1);
  96   1          LCD_EN = 1;
  97   1       delay(1);
  98   1          LCD_EN = 0;  
  99   1      }
 100          /*******************************************************************/
 101          /*                                                                 */
 102          /*写显示数据到LCD                                                  */
 103          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。                               */
 104          /*                                                                 */
 105          /*******************************************************************/
 106          void lcd_wdat(uchar dat)
 107          {                          
 108   1         while(lcd_busy());
 109   1          LCD_RS = 1;
 110   1          LCD_RW = 0;
 111   1          LCD_EN = 0;
 112   1          P0 = dat;
 113   1          delay(1);
 114   1          LCD_EN = 1;
 115   1          delay(1);
 116   1          LCD_EN = 0; 
 117   1      }
C51 COMPILER V9.00   DA                                                                    05/05/2019 09:13:13 PAGE 3   

 118          /*******************************************************************/
 119          /*                                                                 */
 120          /*  LCD初始化设定                                                  */
 121          /*                                                                 */
 122          /*******************************************************************/
 123          void lcd_init()
 124          { 
 125   1      
 126   1          LCD_PSB = 1;         //并口方式
 127   1          
 128   1          lcd_wcmd(0x34);      //扩充指令操作
 129   1          delay(5);
 130   1          lcd_wcmd(0x30);      //基本指令操作
 131   1          delay(5);
 132   1          lcd_wcmd(0x0C);      //显示开，关光标
 133   1          delay(5);
 134   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 135   1          delay(5);
 136   1      }
 137          
 138          /*------------------------------------------------
 139                              启动总线
 140          ------------------------------------------------*/
 141          void Start_I2c()
 142          {
 143   1        SDA=1;   //发送起始条件的数据信号
 144   1        _Nop();
 145   1        SCL=1;
 146   1        _Nop();    //起始条件建立时间大于4.7us,延时
 147   1        _Nop();
 148   1        _Nop();
 149   1        _Nop();
 150   1        _Nop();    
 151   1        SDA=0;     //发送起始信号
 152   1        _Nop();    //起始条件锁定时间大于4μ
 153   1        _Nop();
 154   1        _Nop();
 155   1        _Nop();
 156   1        _Nop();       
 157   1        SCL=0;    //钳住I2C总线，准备发送或接收数据
 158   1        _Nop();
 159   1        _Nop();
 160   1      }
 161          /*------------------------------------------------
 162                              结束总线
 163          ------------------------------------------------*/
 164          void Stop_I2c()
 165          {
 166   1        SDA=0;    //发送结束条件的数据信号
 167   1        _Nop();   //发送结束条件的时钟信号
 168   1        SCL=1;    //结束条件建立时间大于4μ
 169   1        _Nop();
 170   1        _Nop();
 171   1        _Nop();
 172   1        _Nop();
 173   1        _Nop();
 174   1        SDA=1;    //发送I2C总线结束信号
 175   1        _Nop();
 176   1        _Nop();
 177   1        _Nop();
 178   1        _Nop();
 179   1      }
C51 COMPILER V9.00   DA                                                                    05/05/2019 09:13:13 PAGE 4   

 180          
 181          
 182          
 183          
 184          /*----------------------------------------------------------------
 185                           字节数据传送函数               
 186          函数原型: void  SendByte(unsigned char c);
 187          功能:  将数据c发送出去,可以是地址,也可以是数据,发完后等待应答,并对
 188               此状态位进行操作.(不应答或非应答都使ack=0 假)     
 189               发送数据正常，ack=1; ack=0表示被控器无应答或损坏。
 190          ------------------------------------------------------------------*/
 191          void  SendByte(unsigned char c)
 192          {
 193   1       unsigned char BitCnt;
 194   1       
 195   1       for(BitCnt=0;BitCnt<8;BitCnt++)  //要传送的数据长度为8位
 196   1          {
 197   2           if((c<<BitCnt)&0x80)SDA=1;   //判断发送位
 198   2             else  SDA=0;                
 199   2           _Nop();
 200   2           SCL=1;               //置时钟线为高，通知被控器开始接收数据位
 201   2            _Nop(); 
 202   2            _Nop();             //保证时钟高电平周期大于4μ
 203   2            _Nop();
 204   2            _Nop();
 205   2            _Nop();         
 206   2           SCL=0; 
 207   2          }
 208   1          
 209   1          _Nop();
 210   1          _Nop();
 211   1          SDA=1;               //8位发送完后释放数据线，准备接收应答位
 212   1          _Nop();
 213   1          _Nop();   
 214   1          SCL=1;
 215   1          _Nop();
 216   1          _Nop();
 217   1          _Nop();
 218   1          if(SDA==1)ack=0;     
 219   1             else ack=1;        //判断是否接收到应答信号
 220   1          SCL=0;
 221   1          _Nop();
 222   1          _Nop();
 223   1      }
 224          
 225          
 226          
 227          
 228          
 229          
 230          
 231          /*----------------------------------------------------------------
 232                           字节数据传送函数               
 233          函数原型: unsigned char  RcvByte();
 234          功能:  用来接收从器件传来的数据,并判断总线错误(不发应答信号)，
 235               发完后请用应答函数。  
 236          ------------------------------------------------------------------*/    
 237          unsigned char  RcvByte()
 238          {
 239   1        unsigned char retc;
 240   1        unsigned char BitCnt;
 241   1        
C51 COMPILER V9.00   DA                                                                    05/05/2019 09:13:13 PAGE 5   

 242   1        retc=0; 
 243   1        SDA=1;             //置数据线为输入方式
 244   1        for(BitCnt=0;BitCnt<8;BitCnt++)
 245   1            {
 246   2              _Nop();           
 247   2              SCL=0;       //置时钟线为低，准备接收数据位
 248   2              _Nop();
 249   2              _Nop();      //时钟低电平周期大于4.7us
 250   2              _Nop();
 251   2              _Nop();
 252   2              _Nop();
 253   2              SCL=1;       //置时钟线为高使数据线上数据有效
 254   2              _Nop();
 255   2              _Nop();
 256   2              retc=retc<<1;
 257   2              if(SDA==1)retc=retc+1; //读数据位,接收的数据位放入retc中
 258   2              _Nop();
 259   2              _Nop(); 
 260   2            }
 261   1        SCL=0;    
 262   1        _Nop();
 263   1        _Nop();
 264   1        return(retc);
 265   1      }
 266          
 267          
 268          
 269          /*----------------------------------------------------------------
 270                               应答子函数
 271          原型:  void Ack_I2c(void);
 272           
 273          ----------------------------------------------------------------*/
 274          /*void Ack_I2c(void)
 275          {
 276            
 277            SDA=0;     
 278            _Nop();
 279            _Nop();
 280            _Nop();      
 281            SCL=1;
 282            _Nop();
 283            _Nop();              //时钟低电平周期大于4μ
 284            _Nop();
 285            _Nop();
 286            _Nop();  
 287            SCL=0;               //清时钟线，钳住I2C总线以便继续接收
 288            _Nop();
 289            _Nop();    
 290          }*/
 291          /*----------------------------------------------------------------
 292                               非应答子函数
 293          原型:  void NoAck_I2c(void);
 294           
 295          ----------------------------------------------------------------*/
 296          void NoAck_I2c(void)
 297          {
 298   1        
 299   1        SDA=1;
 300   1        _Nop();
 301   1        _Nop();
 302   1        _Nop();      
 303   1        SCL=1;
C51 COMPILER V9.00   DA                                                                    05/05/2019 09:13:13 PAGE 6   

 304   1        _Nop();
 305   1        _Nop();              //时钟低电平周期大于4μ
 306   1        _Nop();
 307   1        _Nop();
 308   1        _Nop();  
 309   1        SCL=0;                //清时钟线，钳住I2C总线以便继续接收
 310   1        _Nop();
 311   1        _Nop();    
 312   1      }
 313          
 314          /////////////////////////////////////
 315          /*********************************************************/
 316          /*                                                                                                               */
 317          /* 主程序                                                                                */
 318          /*                                                       */
 319          /*********************************************************/
 320            main()
 321           {      
 322   1       
 323   1              unsigned int num=0;
 324   1          uchar i,n;
 325   1          delay(10);                 //延时
 326   1          wela=0;
 327   1              dula=0; 
 328   1          lcd_init();                //初始化LCD             
 329   1                      P1M0=0XFF;
 330   1              P1M1=0X00;
 331   1          lcd_pos(0,0);             //设置显示位置为第一行的第1个字符
 332   1           i = 0;
 333   1          while(dis1[i] != '\0')
 334   1           {                         //显示字符
 335   2             lcd_wdat(dis1[i]);
 336   2             i++;
 337   2           }
 338   1          lcd_pos(1,0);             //设置显示位置为第二行的第1个字符
 339   1           i = 0;
 340   1          while(dis2[i] != '\0')
 341   1           {
 342   2             lcd_wdat(dis2[i]);      //显示字符
 343   2             i++;
 344   2           }
 345   1      
 346   1                lcd_pos(3,0);             //设置显示位置为第二行的第1个字符
 347   1           i = 0;
 348   1          while(dis3[i] != '\0')
 349   1           {
 350   2             lcd_wdat(dis3[i]);      //显示字符
 351   2             i++;
 352   2           }
 353   1                 DJ1=0;
 354   1                 DJ2=1;
 355   1           while(1)
 356   1               {
 357   2               for(n=0;n<30;n++)
 358   2               {      
 359   3                        num=ReadADC(3);
 360   3              //        num1+=num;
 361   3                        delay(10);
 362   3               }
 363   2                //     num=num1/20;
 364   2                       num=num*19;
 365   2      //              delay(10);
C51 COMPILER V9.00   DA                                                                    05/05/2019 09:13:13 PAGE 7   

 366   2      //              num=ReadADC(3);                  //转换成mv，最大值255 。255x19=4845mv，
 367   2                  lcd_pos(3,3);
 368   2                      lcd_wdat(mun_to_char[num/1000]);
 369   2                      lcd_wdat(mun_to_char[num%1000/100]);
 370   2                      lcd_wdat(mun_to_char[num%100/10]);
 371   2                      lcd_wdat(mun_to_char[num%10]);
 372   2                      lcd_wdat('V');
 373   2                 num1=0;
 374   2               }
 375   1              
 376   1      }
 377          
 378          
 379          
 380          
 381          /*********************************************************/
 382          /*                                                       */
 383          /* 设定显示位置                                          */
 384          /*                                                       */
 385          /*********************************************************/
 386          void lcd_pos(uchar X,uchar Y)
 387          {                          
 388   1         uchar  pos;
 389   1         if (X==0)
 390   1           {X=0x80;}
 391   1         else if (X==1)
 392   1           {X=0x90;}
 393   1         else if (X==2)
 394   1           {X=0x88;}
 395   1         else if (X==3)
 396   1           {X=0x98;}
 397   1         pos = X+Y ;  
 398   1         lcd_wcmd(pos);     //显示地址
 399   1      }
 400          /*------------------------------------------------
 401                       读AD转值程序
 402          输入参数 Chl 表示需要转换的通道，范围从0-3
 403          返回值范围0-255
 404          ------------------------------------------------*/
 405          unsigned char ReadADC(unsigned char Chl)
 406           {
 407   1         unsigned char Val;
 408   1         Start_I2c();               //启动总线
 409   1         SendByte(AddWr);             //发送器件地址
 410   1           if(ack==0)return(0);
 411   1         SendByte(0x40|Chl);            //发送器件子地址
 412   1           if(ack==0)return(0);
 413   1         Start_I2c();
 414   1         SendByte(AddWr+1);
 415   1            if(ack==0)return(0);
 416   1         Val=RcvByte();
 417   1         NoAck_I2c();                 //发送非应位
 418   1         Stop_I2c();                  //结束总线
 419   1        return(Val);
 420   1       }
 421          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    697    ----
   CONSTANT SIZE    =     41    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.00   DA                                                                    05/05/2019 09:13:13 PAGE 8   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
